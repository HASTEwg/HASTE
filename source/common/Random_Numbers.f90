    Include 'mkl_vsl.f90'  !Include allows use of Intel MKL random number generators
    !TODO Check MKL portability to ARM architectures (if those are a potential target)
    
Module Random_Numbers
    
    Use Kinds, Only: dp
    Use MKL_VSL_TYPE, Only: VSL_STREAM_STATE
    Implicit None
    Private
    Public :: RNG_Type
    Public :: Setup_RNG
    
    Type :: RNG_Type
        Type(VSL_STREAM_STATE) :: stream  !stream state variable for RNG
        Real(dp), Allocatable :: q(:)  !Pre-filled array of random numbers generated by stream
        Integer :: q_size  !size of array q
        Integer :: q_index  !position of next random number to be used in q
        Integer :: seed  !value used to seed the RNG
    Contains
        Procedure, Pass :: Get_Random
        !Procedure, Pass :: Get_Random => Get_1_Random
        !Procedure, Pass :: Get_Randoms => Get_n_Randoms
        Procedure, Pass :: Restart => Restart_RNG
        Procedure, Pass :: Initialize => Initialize_RNG
        Procedure, Pass :: Cleanup => Cleanup_RNG
        Procedure, Pass :: Save_RNG
        Procedure, Pass :: Load_RNG
    End Type
    
    Interface Get_Random
        Module Procedure Get_1_Random
        Module Procedure Get_1_Random_scaled1
        Module Procedure Get_1_Random_scaled2
        Module Procedure Get_n_Randoms
        Module Procedure Get_n_Randoms_scaled1
        Module Procedure Get_n_Randoms_scaled2
    End Interface
    !N2H Improve detail of RNG stat checking to include detailed error trapping rather than general stops in current implementation

Contains
    
Function Setup_RNG(setup_file_name,run_file_name) Result(RNG)
    Use Utilities, Only: Thread_Index
    Use FileIO_Utilities, Only: fSHARE
    Implicit None
    Type(RNG_Type) :: RNG
    Character(*), Intent(In) :: setup_file_name  !file to read for RNG seeding
    Character(*), Intent(In) :: run_file_name  !file to write copy of RNG setup information
    Logical :: RNG_seed_random  !flag indicationg whether the RNG should be started using a random or specific seed
    Integer :: RNG_seed  !specific seed to start RNG
    Integer :: t  !thread or image number, used to start independent RNGs for parallel execution
    Integer :: setup_unit,stat
    
    NameList /RNGSetupList/ RNG_seed_random,RNG_seed
    
    !open setup file and read namelist
    Open(NEWUNIT = setup_unit , FILE = setup_file_name , STATUS = 'OLD' , ACTION = 'READ' , IOSTAT = stat, SHARE = fSHARE)
    If (stat .NE. 0) Then
        Print *,'ERROR:  Random_Numbers: Setup_RNG:  File open error, '//setup_file_name//', IOSTAT=',stat
        ERROR STOP
    End If
    Read(setup_unit,NML = RNGSetupList)
    Close(setup_unit)
    If (RNG_seed_random) Then
        RNG_seed = Create_Random_Seed()
        RNG_seed_random = .TRUE.
    End If
    Call Thread_Index(t)
    If (t .GT. 0) Then !setup is being called from inside a parallel region
        Call RNG%Initialize(seed = RNG_seed , thread = t-1)
    Else  !initialize for serial execution
        Call RNG%Initialize(seed = RNG_seed)
    End If
    If (this_image() .EQ. 1) Then
        Open(NEWUNIT = setup_unit , FILE = run_file_name , STATUS = 'OLD' , ACTION = 'WRITE' , POSITION = 'APPEND' , IOSTAT = stat)
        If (stat .NE. 0) Then
            Print *,'ERROR:  Random_Numbers: Setup_RNG:  File open error, '//run_file_name//', IOSTAT=',stat
            ERROR STOP
        End If
        Write(setup_unit,NML = RNGSetupList)
        Write(setup_unit,*)
        Close(setup_unit)
    End If
End Function Setup_RNG

Subroutine Initialize_RNG(RNG,seed,thread,size)  !Initializes a RNG and returns state variables for that stream
    Use MKL_VSL, Only: vslnewstream,VSL_BRNG_MT2203,VSL_BRNG_SFMT19937
    Use MKL_VSL, Only: VSL_ERROR_OK,VSL_STATUS_OK
    Use MKL_VSL, Only: vdrnguniform,VSL_RNG_METHOD_UNIFORM_STD
    Use Kinds, Only: dp
    Implicit None
    Class(RNG_Type),Intent(Out) :: RNG
    Integer, Intent(In), Optional :: seed  !RNG seed to initialize RNG stream, omission indicates a random seed
    Integer, Intent(In), Optional :: thread  !index of calling thread, omission indicates serial execution
    Integer, Intent(In), Optional :: size  !size of random number array to pre-fill, default 2**12
    Integer :: rng_stat  !status returns from MKL RNG operations
    
    If (Present(size)) Then
        RNG%q_size = size
    Else
        RNG%q_size = 2**12
    End If
    Allocate(RNG%q(1:RNG%q_size))
    If (Present(seed)) Then
        RNG%seed = seed
    Else  !Generate a random seed using intrinsic RNG seeded with default seed (date-and-time based)
        RNG%seed = Create_Random_Seed()  !sets seed to a value between [0,Huge) based on current date and time
    End If
    If (Present(thread)) Then  !Parallel execution, use an independent MT2203 stream for each thread
        rng_stat = vslnewstream(RNG%stream,VSL_BRNG_MT2203+thread,RNG%seed)
    Else  !serial execution, use SIMD-oriented fast MT19937
        !rng_stat = vslnewstream(RNG%stream,VSL_BRNG_MT2203+1,RNG%seed)
        rng_stat = vslnewstream(RNG%stream,VSL_BRNG_SFMT19937,RNG%seed)
    End If
    If (Not(rng_stat.EQ.VSL_ERROR_OK .OR. rng_stat.EQ.VSL_STATUS_OK)) Then
        Print *,'ERROR:  Random_Numbers: Initialize_RNG:  MKL RNG stream creation failed, STAT = ',rng_stat
        ERROR STOP
    End If
    rng_stat = vdrnguniform(VSL_RNG_METHOD_UNIFORM_STD,RNG%stream,RNG%q_size,RNG%q,0._dp,1._dp)
    If (Not(rng_stat.EQ.VSL_ERROR_OK .OR. rng_stat.EQ.VSL_STATUS_OK)) Then
        Print *,'ERROR:  Random_Numbers: Initialize_RNG:  MKL RNG stream initial fill q failed, STAT = ',rng_stat
        ERROR STOP
    End If
    RNG%q_index = 1
End Subroutine Initialize_RNG

Function Create_Random_Seed() Result(s)
    Use Kinds, Only: dp
    Implicit None
    Integer :: s
    Real(dp) :: r  !holder for random real used to generate random seed
    
    !Seed the intrinsic RNG based on system defaults (usually date/time)
    Call RANDOM_SEED()
    !Using the intrinsic RNG, generate a seed
    Call RANDOM_NUMBER(r)
    s = Floor(r*Real(Huge(s),dp))  !sets seed to a value between [0,Huge)
End Function Create_Random_Seed

Function Get_1_Random(RNG) Result(r)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: r
    Class(RNG_Type), Intent(InOut) :: RNG  !RNG stream state variable from which to get r
    
    r = RNG%q(RNG%q_index)  !get random number from the array
    If (RNG%q_index .EQ. RNG%q_size) Then !random array exhaused, need to refresh q
        Call Refresh_Random_Array(RNG)
    Else  !increment index
        RNG%q_index = RNG%q_index + 1
    End If
End Function Get_1_Random

Function Get_1_Random_scaled1(RNG,x) Result(r)
    !Same as Get_1_Random, but maps result onto [0,x)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: r
    Class(RNG_Type), Intent(InOut) :: RNG  !RNG stream state variable from which to get r
    Real(dp), Intent(In) :: x
    
    r = x * RNG%Get_Random()  !get random number from the array and map onto [0,x)
End Function Get_1_Random_scaled1

Function Get_1_Random_scaled2(RNG,x,y) Result(r)
    !Same as Get_1_Random, but maps result onto [x,y)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: r
    Class(RNG_Type), Intent(InOut) :: RNG  !RNG stream state variable from which to get r
    Real(dp), Intent(In) :: x,y
    
    r = x + RNG%Get_Random() * (y - x)  !get random number from the array and map onto [x,y)
End Function Get_1_Random_scaled2

Function Get_n_Randoms(RNG,n) Result(r)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: r(n)
    Class(RNG_Type), Intent(InOut) :: RNG
    Integer,Intent(In) :: n  !number of elements in r
    Integer :: m
    
    m = RNG%q_index + n - 1  !index of the final q needed to fill r
    If (m .LE. RNG%q_size) Then  !There are enough numbers left in th array for the request
        r = RNG%q(RNG%q_index:m)
        RNG%q_index = RNG%q_index + n
    Else  !There are not enough numbers in the array for the request
        m = RNG%q_size - RNG%q_index + 1  !q remaining in random array
        r(1:m) = RNG%q(RNG%q_index:RNG%q_size)  !exhaust the random array into the first m entries of r
        Call Refresh_Random_Array(RNG)  !Refresh the random array
        r(m+1:n) = RNG%q(1:n-m)  !fill the remaining n-m entries of r
        RNG%q_index = n - m + 1
    End If
    If (RNG%q_index .GE. RNG%q_size) Then !random array exhaused, need to refresh q
        Call Refresh_Random_Array(RNG)
    End If
End Function Get_n_Randoms

Function Get_n_Randoms_scaled1(RNG,n,x) Result(r)
    !Same as Get_n_Randoms, but maps result onto [0,x)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: r(n)
    Class(RNG_Type), Intent(InOut) :: RNG
    Integer,Intent(In) :: n  !number of elements in r
    Real(dp), Intent(In) :: x
    
    r = x * RNG%Get_Random(n)  !get random numbers from the array and map onto [0,x)
    !If the new interface for choosing the appropriate "Get_Random" doesn't compile, replace the previous line with:
    !r = x * RNG%Get_Randoms(n)  !get random numbers from the array and map onto [0,x)
End Function Get_n_Randoms_scaled1

Function Get_n_Randoms_scaled2(RNG,n,x,y) Result(r)
    !Same as Get_n_Randoms, but maps result onto [x,y)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: r(n)
    Class(RNG_Type), Intent(InOut) :: RNG
    Integer,Intent(In) :: n  !number of elements in r
    Real(dp), Intent(In) :: x,y
    
    r = x + RNG%Get_Random(n) * (y - x)  !get random numbers from the array and map onto [x,y)
    !If the new interface for choosing the appropriate "Get_Random" doesn't compile, replace the previous line with:
    !r = x + RNG%Get_Randoms(n) * (y - x)  !get random numbers from the array and map onto [x,y)
End Function Get_n_Randoms_scaled2

Subroutine Refresh_Random_Array(RNG)
    Use MKL_VSL, Only: VSL_ERROR_OK,VSL_STATUS_OK
    Use MKL_VSL, Only: vdrnguniform,VSL_RNG_METHOD_UNIFORM_STD
    Use Kinds, Only: dp
    Implicit None
    Type(RNG_Type), Intent(InOut) :: RNG
    Integer :: rng_stat  !status returns from MKL RNG operations
    
    rng_stat = vdrnguniform(VSL_RNG_METHOD_UNIFORM_STD,RNG%stream,RNG%q_size,RNG%q,0._dp,1._dp)
    If (Not(rng_stat.EQ.VSL_ERROR_OK .OR. rng_stat.EQ.VSL_STATUS_OK)) Then
        Print *,'ERROR:  Random_Numbers: Refresh_Random_Array:  MKL RNG q_fill failed, STAT = ',rng_stat
        ERROR STOP
    End If
    RNG%q_index = 1
End Subroutine Refresh_Random_Array

Subroutine Restart_RNG(RNG)
    Use OMP_LIB, Only: OMP_GET_NUM_THREADS,OMP_GET_THREAD_NUM
    Use MKL_VSL, Only: vsldeletestream,vslnewstream
    Use MKL_VSL, Only: VSL_BRNG_MT2203,VSL_BRNG_SFMT19937
    Use MKL_VSL, Only: VSL_ERROR_OK,VSL_STATUS_OK
    Use MKL_VSL, Only: vdrnguniform,VSL_RNG_METHOD_UNIFORM_STD
    Implicit None
    Class(RNG_Type), Intent(InOut) :: RNG
    Integer :: rng_stat  !status returns from MKL RNG operations
    Integer :: thread
    
    rng_stat = vsldeletestream(RNG%stream)
    If (OMP_GET_NUM_THREADS().GT.1 .OR. num_images().GT.1) Then !setup is being called from inside a parallel region
        If (OMP_GET_NUM_THREADS() .GT. 1) Then  !use the OpenMP thread number to choose the RNG stream
            thread = OMP_GET_THREAD_NUM()  !OpenMP threads are numbered starting at zero
        Else If (num_images() .GT. 1) Then  !use the coarray image number to choose the RNG stream
            thread = this_image() - 1  !coarray images are numbered starting at 1
        Else
            Print *,'ERROR:  Random_Numbers: Restart_RNG:  Unable to resolve thread or image number.'
            ERROR STOP
        End If
        rng_stat = vslnewstream(RNG%stream,VSL_BRNG_MT2203+thread,RNG%seed)
    Else  !initialize for serial execution
        rng_stat = vslnewstream(RNG%stream,VSL_BRNG_SFMT19937,RNG%seed)
    End If
    If (Not(rng_stat.EQ.VSL_ERROR_OK .OR. rng_stat.EQ.VSL_STATUS_OK)) Then
        Print *,'ERROR:  Random_Numbers: Restart_RNG:  MKL RNG stream creation failed, STAT = ',rng_stat
        ERROR STOP
    End If
    rng_stat = vdrnguniform(VSL_RNG_METHOD_UNIFORM_STD,RNG%stream,RNG%q_size,RNG%q,0._dp,1._dp)
    If (Not(rng_stat.EQ.VSL_ERROR_OK .OR. rng_stat.EQ.VSL_STATUS_OK)) Then
        Print *,'ERROR:  Random_Numbers: Restart_RNG:  MKL RNG stream initial fill q failed, STAT = ',rng_stat
        ERROR STOP
    End If
    RNG%q_index = 1
End Subroutine Restart_RNG

Subroutine Cleanup_RNG(RNG)
    Use MKL_VSL, Only: vsldeletestream
    Implicit None
    Class(RNG_Type), Intent(InOut) :: RNG
    Integer :: rng_stat  !status returns from MKL RNG operations
    
    rng_stat = vsldeletestream(RNG%stream)
    Deallocate(RNG%q)
    RNG%q_size = 0
    RNG%q_index = 0
    RNG%seed = 0
End Subroutine Cleanup_RNG

Subroutine Save_RNG(RNG,dir)
    Use IFPORT, Only: $MAXPATH
    Use MKL_VSL, Only: vslsavestreamF
    Use Utilities, Only: Thread_Index
    Use FileIO_Utilities, Only: Var_to_file
    Implicit None
    Class(RNG_Type), Intent(In) :: RNG
    Character(*), Intent(In) :: dir
    Integer :: i
    Character(4) :: i_char
    Character(:), Allocatable :: fname
    Integer :: stat
    
    Call Thread_Index(i)
    Write(i_char,'(I4.4)') i
    Allocate(Character($MAXPATH) :: fname)
    fname = dir//'RNGstate'//i_char//'.bin'
    stat = vslsavestreamF( RNG%stream, fname )
    If (stat .NE. 0) Then
        Print *,'ERROR:  Random_Numbers: Save_RNG:  File open error, '//fname//', IOSTAT=',stat
        ERROR STOP
    End If
    fname = dir//'RNGs'//i_char//'.bin'
    Call Var_to_file( RNG%seed , fname )
    fname = dir//'RNGqs'//i_char//'.bin'
    Call Var_to_file( RNG%q_size , fname )
    fname = dir//'RNGqi'//i_char//'.bin'
    Call Var_to_file( RNG%q_index, fname )
    fname = dir//'RNGq'//i_char//'.bin'
    Call Var_to_file( RNG%q, fname )
End Subroutine Save_RNG

Subroutine Load_RNG(RNG,dir)
    Use IFPORT, Only: $MAXPATH
    Use MKL_VSL, Only: vslloadstreamF
    Use Utilities, Only: Thread_Index
    Use FileIO_Utilities, Only: Var_from_file
    Implicit None
    Class(RNG_Type), Intent(Out) :: RNG
    Character(*), Intent(In) :: dir
    Integer :: i
    Character(4) :: i_char
    Character(:), Allocatable :: fname
    Integer :: stat
    
    Call Thread_Index(i)
    Write(i_char,'(I4.4)') i
    Allocate(Character($MAXPATH) :: fname)
    fname = dir//'RNGstate'//i_char//'.bin'
    stat = vslloadstreamF( RNG%stream, fname )
    If (stat .NE. 0) Then
        Print *,'ERROR:  Random_Numbers: Load_RNG:  File open error, '//fname//', IOSTAT=',stat
        ERROR STOP
    End If
    fname = dir//'RNGs'//i_char//'.bin'
    Call Var_from_file( RNG%seed , fname )
    fname = dir//'RNGqs'//i_char//'.bin'
    Call Var_from_file( RNG%q_size , fname )
    fname = dir//'RNGqi'//i_char//'.bin'
    Call Var_from_file( RNG%q_index, fname )
    Allocate(RNG%q(1:RNG%q_size))
    fname = dir//'RNGq'//i_char//'.bin'
    Call Var_from_file( RNG%q, fname )
End Subroutine Load_RNG

Function Invert_CDF_O1(xi,x1,x2) Result(x)
    !Inverts the CDF from a general uniform probability distribution (PDF order zero, CDF order 1)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: x
    Real(dp), Intent(In) :: xi  !sampled cumulative probability [0,1)
    Real(dp), Intent(In) :: x1,x2  !range of x
    
    x = x1 + xi * (x2 - x1)
End Function Invert_CDF_O0

Function Invert_CDF_O2(xi,x1,dx,y1,m) Result(x)
    !Inverts the CDF from a general linear probability distribution (PDF order 1, CDF order 2)
    Use Kinds, Only: dp
    Use Utilities, Only: Larger_Quadratic_root
    Implicit None
    Real(dp) :: x
    Real(dp), Intent(In) :: xi  !sampled cumulative probability [0,1)
    Real(dp), Intent(In) :: x1,dx  !starting value and range of x
    Real(dp), Intent(In) :: y1  !pdf vaues at x1
    Real(dp), Intent(In) :: m  !pdf slope
    Real(dp) :: b,c
    
    b = y1/m - x1
    c = (x1*(2._dp*y1 - m*x1) + dx*xi*(dx*m + 2._dp*y1)) / m
    x = Larger_Quadratic_root(b,c)
    !The larger quadratic root is computed first for precision, but only one of the roots lies between x1 and x2
    !If the larger root is not on (x1,x2), then the smaller root is:
    If (x.GT.x2 .OR. x.LT.x1) x = -c / x
End Function Invert_CDF_O2

Function Invert_CDF_O2(xi,x1,dx,y1,y2) Result(x)
    !Inverts the CDF from a general quadratic probability distribution (PDF order 2, CDF order 3)
    Use Kinds, Only: dp
    Implicit None
    Real(dp) :: x
    Real(dp), Intent(In) :: xi  !sampled cumulative probability [0,1)
    Real(dp), Intent(In) :: x1,dx  !!starting value and range of x
    Real(dp), Intent(In) :: y1,y2  !pdf vaues at x1 and x2
    Real(dp) :: b,c
    
End Function Invert_CDF_O2

End Module Random_Numbers
